{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Les algorithmes de bases \u2693\ufe0e \" J\u2019entends et j\u2019oublie, Je vois et je me souviens, Je fais et je comprends..\" (Confucius) Les machines ne r\u00e9solvent pas des probl\u00e8mes, elles ne font qu'ex\u00e9cuter une succession de t\u00e2ches simples. Le travail du \"programmeur\" consiste \u00e0 : Analyser le probl\u00e8me Mettre au point une m\u00e9thode pour le r\u00e9soudre trouver une structure adapt\u00e9e pour repr\u00e9senter les donn\u00e9es \"verbaliser\" la m\u00e9thode de r\u00e9solution Traduire la m\u00e9thode envisag\u00e9e dans le langage choisi Tester le programme (pour \u00e9ventuellement d\u00e9tecter des erreurs et/ou des oublis de cas particuliers) Sur cet espace, vous \u00eates invit\u00e9s \u00e0 faire ces diff\u00e9rentes d\u00e9marches \u00e0 travers quelques exemples simples.","title":"\ud83c\udfe1 Accueil"},{"location":"#les-algorithmes-de-bases","text":"\" J\u2019entends et j\u2019oublie, Je vois et je me souviens, Je fais et je comprends..\" (Confucius) Les machines ne r\u00e9solvent pas des probl\u00e8mes, elles ne font qu'ex\u00e9cuter une succession de t\u00e2ches simples. Le travail du \"programmeur\" consiste \u00e0 : Analyser le probl\u00e8me Mettre au point une m\u00e9thode pour le r\u00e9soudre trouver une structure adapt\u00e9e pour repr\u00e9senter les donn\u00e9es \"verbaliser\" la m\u00e9thode de r\u00e9solution Traduire la m\u00e9thode envisag\u00e9e dans le langage choisi Tester le programme (pour \u00e9ventuellement d\u00e9tecter des erreurs et/ou des oublis de cas particuliers) Sur cet espace, vous \u00eates invit\u00e9s \u00e0 faire ces diff\u00e9rentes d\u00e9marches \u00e0 travers quelques exemples simples.","title":"Les algorithmes de bases"},{"location":"divers/","text":"Des exercices \u2693\ufe0e \u00c9locution chez le dentiste \u2693\ufe0e Chez le dentiste, la bouche grande ouverte, lorsqu'on essaie de parler, il ne reste que les voyelles. M\u00eame les ponctuations sont supprim\u00e9es. Vous devez \u00e9crire une fonction dentiste qui prend une chaine de caract\u00e8res texte et qui renvoie une autre chaine ne contenant que les voyelles de texte, plac\u00e9es dans l'ordre. Les voyelles sont donn\u00e9es par : VOYELLES = [ 'a' , 'e' , 'i' , 'o' , 'u' , 'y' ] On ne consid\u00e8rera que des textes \u00e9crits en minuscules, sans accents. Exemples dentiste ( \"j'ai mal\" ) # affiche 'aia' dentiste ( \"il fait chaud\" ) # affiche 'iaiau' dentiste ( \"\" ) # affiche '' la fonction devra passer les tests suivants: assert dentiste ( \"j'ai mal\" ) == 'aia' assert dentiste ( \"il fait chaud\" ) == 'iaiau' assert dentiste ( \"\" ) == '' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Rendu de monnaie \u2693\ufe0e On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : rendu ( 13 ) # affiche [ 2 , 1 , 1 ] rendu ( 64 ) # affiche [ 12 , 2 , 0 ] rendu ( 89 ) #affiche [ 17 , 2 , 0 ] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Conversion \u2693\ufe0e Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z XOR \u2693\ufe0e L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents : 0 \u2295 0 = 0 , 0 \u2295 1 = 1 , 1 \u2295 0 = 1 , 1 \u2295 1 = 0 On repr\u00e9sente ici une suite de bits par un tableau contenant des 0 et des 1. Exemples : a = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 ] b = [ 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 ] c = [ 1 , 1 , 0 , 1 ] d = [ 0 , 0 , 1 , 1 ] \u00c9crire la fonction xor qui prend en param\u00e8tres deux tableaux de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position i est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position i des tableaux pass\u00e9s en param\u00e8tres. En consid\u00e9rant les quatre exemples ci-dessus, cette fonction doit passer les tests suivants : assert ( xor ( a , b ) == [ 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ]) assert ( xor ( c , d ) == [ 1 , 1 , 1 , 0 ]) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Tri it\u00e9ratif \u2693\ufe0e On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient t = [41, 25, 21, 18, 12, 6, 55] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le dernier , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : t = [6, 25, 21, 18, 12, 41, 55] Et ainsi de suite. La code de la fonction tri_iteratif qui impl\u00e9mente cet algorithme est donn\u00e9 ci-dessous. def tri_iteratif ( tab ): for k in range ( ... , 0 , - 1 ): imax = ... for i in range ( 0 , ... ): if tab [ i ] > ... : imax = i if tab [ imax ] > ... : ... , tab [ imax ] = tab [ imax ], ... return tab Compl\u00e9ter le code qui doit passer ce test : assert tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) == [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b. ``` Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Delta encoding \u2693\ufe0e Le codage par diff\u00e9rence (delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta_encoding qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tuple \u00e0 deux \u00e9l\u00e9ments comprenant : En premier, la valeur initiale En second, le tableau des diff\u00e9rences, contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l'aide de cette technique. la fonction devra passer le test suivant: assert delta_encoding ([ 1000000 , 1000042 , 1000040 , 1000055 , 1000010 ]) == ( 1000000 , [ 42 , - 2 , 15 , - 45 ]) assert delta_encoding ([ 42 ]) == ( 42 , []) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Divers"},{"location":"divers/#des-exercices","text":"","title":"Des exercices"},{"location":"divers/#elocution-chez-le-dentiste","text":"Chez le dentiste, la bouche grande ouverte, lorsqu'on essaie de parler, il ne reste que les voyelles. M\u00eame les ponctuations sont supprim\u00e9es. Vous devez \u00e9crire une fonction dentiste qui prend une chaine de caract\u00e8res texte et qui renvoie une autre chaine ne contenant que les voyelles de texte, plac\u00e9es dans l'ordre. Les voyelles sont donn\u00e9es par : VOYELLES = [ 'a' , 'e' , 'i' , 'o' , 'u' , 'y' ] On ne consid\u00e8rera que des textes \u00e9crits en minuscules, sans accents. Exemples dentiste ( \"j'ai mal\" ) # affiche 'aia' dentiste ( \"il fait chaud\" ) # affiche 'iaiau' dentiste ( \"\" ) # affiche '' la fonction devra passer les tests suivants: assert dentiste ( \"j'ai mal\" ) == 'aia' assert dentiste ( \"il fait chaud\" ) == 'iaiau' assert dentiste ( \"\" ) == '' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"\u00c9locution chez le dentiste"},{"location":"divers/#rendu-de-monnaie","text":"On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : rendu ( 13 ) # affiche [ 2 , 1 , 1 ] rendu ( 64 ) # affiche [ 12 , 2 , 0 ] rendu ( 89 ) #affiche [ 17 , 2 , 0 ] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Rendu de monnaie"},{"location":"divers/#conversion","text":"Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Conversion"},{"location":"divers/#xor","text":"L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents : 0 \u2295 0 = 0 , 0 \u2295 1 = 1 , 1 \u2295 0 = 1 , 1 \u2295 1 = 0 On repr\u00e9sente ici une suite de bits par un tableau contenant des 0 et des 1. Exemples : a = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 ] b = [ 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 ] c = [ 1 , 1 , 0 , 1 ] d = [ 0 , 0 , 1 , 1 ] \u00c9crire la fonction xor qui prend en param\u00e8tres deux tableaux de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position i est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position i des tableaux pass\u00e9s en param\u00e8tres. En consid\u00e9rant les quatre exemples ci-dessus, cette fonction doit passer les tests suivants : assert ( xor ( a , b ) == [ 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ]) assert ( xor ( c , d ) == [ 1 , 1 , 1 , 0 ]) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"XOR"},{"location":"divers/#tri-iteratif","text":"On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient t = [41, 25, 21, 18, 12, 6, 55] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le dernier , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : t = [6, 25, 21, 18, 12, 41, 55] Et ainsi de suite. La code de la fonction tri_iteratif qui impl\u00e9mente cet algorithme est donn\u00e9 ci-dessous. def tri_iteratif ( tab ): for k in range ( ... , 0 , - 1 ): imax = ... for i in range ( 0 , ... ): if tab [ i ] > ... : imax = i if tab [ imax ] > ... : ... , tab [ imax ] = tab [ imax ], ... return tab Compl\u00e9ter le code qui doit passer ce test : assert tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) == [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b. ``` Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Tri it\u00e9ratif"},{"location":"divers/#delta-encoding","text":"Le codage par diff\u00e9rence (delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta_encoding qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tuple \u00e0 deux \u00e9l\u00e9ments comprenant : En premier, la valeur initiale En second, le tableau des diff\u00e9rences, contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l'aide de cette technique. la fonction devra passer le test suivant: assert delta_encoding ([ 1000000 , 1000042 , 1000040 , 1000055 , 1000010 ]) == ( 1000000 , [ 42 , - 2 , 15 , - 45 ]) assert delta_encoding ([ 42 ]) == ( 42 , []) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Delta encoding"},{"location":"recherche/","text":"Maximum et minimum \u2693\ufe0e La plupart des algorithmes de recherche de maximum ou de minimum sont bas\u00e9s sur le principe suivant : On initialise une variable maxi ou mini suivant le contexte On parcourt les \u00e9l\u00e9ments \u00e0 comparer en rempla\u00e7ant le maxi (ou mini ) si n\u00e9cessaire Maximum et minimum d'une liste d'entiers \u2693\ufe0e \u00c9crire une fonction extremum(liste) qui renvoie le maximum et le minimum des \u00e9l\u00e9ments de la liste sous forme d'un tuple (maxi , mini) , sans bien s\u00fbr utiliser les fonctions min et max de python Cette fonction devra passer les tests suivants: assert extremum ([ 1 , - 2 , 12 , 5 , 54 , - 10 ]) == ( - 10 , 54 ) assert extremum ([]) == 'liste vide' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Une tableau de tuples \u2693\ufe0e \u00c9crire une fonction maximum1(tableau) qui renvoie le tuple dont le second \u00e9l\u00e9ment est le plus grand. Cette fonction devra passer les tests suivants: assert extremum ([( 12 , - 5 ),( 5 , 13 ),( - 9 , 15 ),( 0 , 0 )]) == ( - 9 , 15 ) assert extremum ([]) == 'liste vide' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Un dictionnaire \u2693\ufe0e On consid\u00e8re le dictionnaire suivant, dont les cl\u00e9s sont des noms d'\u00e9l\u00e8ves et les valeurs des notes. classe = { \"g\u00e9rard\" :[ 12 , 8 , 6 , 15 ], \"louis\" :[ 17 , 5 , 12 ], \"sylvie\" :[ 2 , 18 , 15 , 13 ], \"mariane\" :[ 12 , 13 , 7 , 10 ]} \u00c9crire une fonction maximum2(classe) qui renvoie l'\u00e9l\u00e8ve qui a la meilleure moyenne et sa moyenne sous forme de tuple, le r\u00e9sultat attendu est ('sylvie', 12.0) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Recherche d'\u00e9l\u00e9ments dans un tableau Recherche d'un \u00e9l\u00e9ment dans un tableau non tri\u00e9 \u2693\ufe0e La recherche d'un objet dans un tableau, consiste \u00e0 parcourir le tableau et \u00e0 renvoyer True si l'objet est trouv\u00e9 et False sinon. \u00c9crire une fonction recherche1(tab,element) qui renvoie True si l'\u00e9l\u00e9ment est pr\u00e9sent dans le ntableau et False sinon Cette fonction devra passer les tests suivants: assert recherche1 ([ 1 , - 2 , 5 , - 4 , 0 , 10 , 45 ], 0 ) == True assert recherche1 ([ 1 , - 2 , 5 , - 4 , 0 , 10 , 45 ], 2 ) == False assert recherche ([ 'lapin' , 'autruche' , 'castor' , 'chat' , 'chien' ], 'chien' ) == True assert recherche1 ([], 0 ) == 'tableau vide' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Recherche dans un tableau tri\u00e9 \u2693\ufe0e On utilise ici l'algorithme de recherche par dichotomie, copier-coller le code \u00e0 compl\u00e9ter ci-dessous et compl\u00e9ter-le. def recherche2 ( tab , element ): debut = ... fin = ... while debut <= ... : milieu = ( ....... ) // 2 if tab [ milieu ] == ..... : return .... else : if ...... : fin = milieu - 1 else : debut = milieu + 1 return False t = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] assert recherche2 ( t , - 1 ) == False assert recherche2 ( t , 0 ) == True assert recherche2 ( t , 7 ) == True assert recherche2 ( t , 14 ) == True assert recherche2 ( t , 15 ) == False Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Pour le 3.6 et 3.7, on n'utilisera ni la fonction index, ni la fonction find. Rappel On peut parcourir les tableaux(liste) et les cha\u00eenes de caract\u00e8res par leur indices: ma_chaine = 'ceci est un exmple' for i in range ( len ( ma_chaine )): print ( machaine [ i ]) # affiche toutes les lettre de ma_chaine Indice de la premi\u00e8re occurrence \u2693\ufe0e \u00c9crire une fonction indice qui prend en param\u00e8tres element un nombre entier, tableau un tableau de nombres entiers, et qui renvoie l'indice de la premi\u00e8re occurrence de element dans tableau . La fonction devra renvoyer None si element est absent de tableau # Exemple indice ( 1 , [ 10 , 12 , 1 , 56 ]) #affiche 2 indice ( 1 , [ 1 , 50 , 1 ]) #affiche 0 indice ( 15 , [ 8 , 9 , 10 , 15 ]) #affiche 3 indice ( 1 , [ 2 , 3 , 4 ]) #affiche None Cette fonction devra passer les tests suivants: assert indice ( 1 , [ 10 , 12 , 1 , 56 ]) == 2 assert indice ( 1 , [ 1 , 50 , 1 ]) == 0 assert indice ( 15 , [ 8 , 9 , 10 , 15 ]) == 3 assert indice ( 1 , [ 2 , 3 , 4 ]) is None Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Occurrences d'un caract\u00e8re dans un mot \u2693\ufe0e \u00c9crire une fonction compte_occurrences qui prend en param\u00e8tres cible , un caract\u00e8re (une chaine de caract\u00e8res de longueur 1), et mot , une chaine de caract\u00e8res, et qui renvoie le nombre d'occurrences de cible dans mot ; c'est-\u00e0-dire le nombre de fois o\u00f9 cible apparait dans mot . On n'utilisera pas la m\u00e9thode count . Cette fonction devra passer les tests suivants: assert compte_occurrences ( \"o\" , \"bonjour\" ) == 2 assert compte_occurrences ( \"a\" , \"abracadabra\" ) == 5 assert compte_occurrences ( \"i\" , \"abracadabra\" ) == 0 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Recherche"},{"location":"recherche/#maximum-et-minimum","text":"La plupart des algorithmes de recherche de maximum ou de minimum sont bas\u00e9s sur le principe suivant : On initialise une variable maxi ou mini suivant le contexte On parcourt les \u00e9l\u00e9ments \u00e0 comparer en rempla\u00e7ant le maxi (ou mini ) si n\u00e9cessaire","title":"Maximum et minimum"},{"location":"recherche/#maximum-et-minimum-dune-liste-dentiers","text":"\u00c9crire une fonction extremum(liste) qui renvoie le maximum et le minimum des \u00e9l\u00e9ments de la liste sous forme d'un tuple (maxi , mini) , sans bien s\u00fbr utiliser les fonctions min et max de python Cette fonction devra passer les tests suivants: assert extremum ([ 1 , - 2 , 12 , 5 , 54 , - 10 ]) == ( - 10 , 54 ) assert extremum ([]) == 'liste vide' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Maximum et minimum d'une liste d'entiers"},{"location":"recherche/#une-tableau-de-tuples","text":"\u00c9crire une fonction maximum1(tableau) qui renvoie le tuple dont le second \u00e9l\u00e9ment est le plus grand. Cette fonction devra passer les tests suivants: assert extremum ([( 12 , - 5 ),( 5 , 13 ),( - 9 , 15 ),( 0 , 0 )]) == ( - 9 , 15 ) assert extremum ([]) == 'liste vide' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Une tableau de tuples"},{"location":"recherche/#un-dictionnaire","text":"On consid\u00e8re le dictionnaire suivant, dont les cl\u00e9s sont des noms d'\u00e9l\u00e8ves et les valeurs des notes. classe = { \"g\u00e9rard\" :[ 12 , 8 , 6 , 15 ], \"louis\" :[ 17 , 5 , 12 ], \"sylvie\" :[ 2 , 18 , 15 , 13 ], \"mariane\" :[ 12 , 13 , 7 , 10 ]} \u00c9crire une fonction maximum2(classe) qui renvoie l'\u00e9l\u00e8ve qui a la meilleure moyenne et sa moyenne sous forme de tuple, le r\u00e9sultat attendu est ('sylvie', 12.0) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Recherche d'\u00e9l\u00e9ments dans un tableau","title":"Un dictionnaire"},{"location":"recherche/#recherche-dun-element-dans-un-tableau-non-trie","text":"La recherche d'un objet dans un tableau, consiste \u00e0 parcourir le tableau et \u00e0 renvoyer True si l'objet est trouv\u00e9 et False sinon. \u00c9crire une fonction recherche1(tab,element) qui renvoie True si l'\u00e9l\u00e9ment est pr\u00e9sent dans le ntableau et False sinon Cette fonction devra passer les tests suivants: assert recherche1 ([ 1 , - 2 , 5 , - 4 , 0 , 10 , 45 ], 0 ) == True assert recherche1 ([ 1 , - 2 , 5 , - 4 , 0 , 10 , 45 ], 2 ) == False assert recherche ([ 'lapin' , 'autruche' , 'castor' , 'chat' , 'chien' ], 'chien' ) == True assert recherche1 ([], 0 ) == 'tableau vide' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Recherche d'un \u00e9l\u00e9ment dans un tableau non tri\u00e9"},{"location":"recherche/#recherche-dans-un-tableau-trie","text":"On utilise ici l'algorithme de recherche par dichotomie, copier-coller le code \u00e0 compl\u00e9ter ci-dessous et compl\u00e9ter-le. def recherche2 ( tab , element ): debut = ... fin = ... while debut <= ... : milieu = ( ....... ) // 2 if tab [ milieu ] == ..... : return .... else : if ...... : fin = milieu - 1 else : debut = milieu + 1 return False t = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] assert recherche2 ( t , - 1 ) == False assert recherche2 ( t , 0 ) == True assert recherche2 ( t , 7 ) == True assert recherche2 ( t , 14 ) == True assert recherche2 ( t , 15 ) == False Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Pour le 3.6 et 3.7, on n'utilisera ni la fonction index, ni la fonction find. Rappel On peut parcourir les tableaux(liste) et les cha\u00eenes de caract\u00e8res par leur indices: ma_chaine = 'ceci est un exmple' for i in range ( len ( ma_chaine )): print ( machaine [ i ]) # affiche toutes les lettre de ma_chaine","title":"Recherche dans un tableau tri\u00e9"},{"location":"recherche/#indice-de-la-premiere-occurrence","text":"\u00c9crire une fonction indice qui prend en param\u00e8tres element un nombre entier, tableau un tableau de nombres entiers, et qui renvoie l'indice de la premi\u00e8re occurrence de element dans tableau . La fonction devra renvoyer None si element est absent de tableau # Exemple indice ( 1 , [ 10 , 12 , 1 , 56 ]) #affiche 2 indice ( 1 , [ 1 , 50 , 1 ]) #affiche 0 indice ( 15 , [ 8 , 9 , 10 , 15 ]) #affiche 3 indice ( 1 , [ 2 , 3 , 4 ]) #affiche None Cette fonction devra passer les tests suivants: assert indice ( 1 , [ 10 , 12 , 1 , 56 ]) == 2 assert indice ( 1 , [ 1 , 50 , 1 ]) == 0 assert indice ( 15 , [ 8 , 9 , 10 , 15 ]) == 3 assert indice ( 1 , [ 2 , 3 , 4 ]) is None Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Indice de la premi\u00e8re occurrence"},{"location":"recherche/#occurrences-dun-caractere-dans-un-mot","text":"\u00c9crire une fonction compte_occurrences qui prend en param\u00e8tres cible , un caract\u00e8re (une chaine de caract\u00e8res de longueur 1), et mot , une chaine de caract\u00e8res, et qui renvoie le nombre d'occurrences de cible dans mot ; c'est-\u00e0-dire le nombre de fois o\u00f9 cible apparait dans mot . On n'utilisera pas la m\u00e9thode count . Cette fonction devra passer les tests suivants: assert compte_occurrences ( \"o\" , \"bonjour\" ) == 2 assert compte_occurrences ( \"a\" , \"abracadabra\" ) == 5 assert compte_occurrences ( \"i\" , \"abracadabra\" ) == 0 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Occurrences d'un caract\u00e8re dans un mot"},{"location":"sommes/","text":"Sommes en tout genre \u2693\ufe0e La plupart des algorithmes de calcul de somme sont bas\u00e9s sur le principe suivant: On initialise une variable somme \u00e0 \\(0\\) On parcourt les \u00e9l\u00e9ments \u00e0 additionner en les ajoutant au fur et \u00e0 mesure \u00e0 somme Rappel : Parcours de listes Il y a deux fa\u00e7ons de parcourir des listes. Sur les \u00e9l\u00e9ments : for el in liste : instructions Sur les indices : for i in range ( len ( liste )): instructions Somme des \u00e9l\u00e9ments d'une liste d'entiers \u2693\ufe0e On consid\u00e8re une liste d'entiers [ 5, 0, 4, -5, 1, -3] et on souhaite calculer la somme de ses \u00e9l\u00e9ments. Sans utiliser la fonction sum de python, \u00e9crire une fonction somme1(liste) ci-dessous qui devra r\u00e9ussir les tests : assert somme1 ([ 0 , 1 , 2 , 3 ]) == 6 assert somme1 ([ 5 , 0 , 4 , - 5 , 1 , - 3 ]) == 2 assert somme1 ([]) == 0 assert somme1 ([ 1 ]) == 1 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Sommes des \u00e9l\u00e9ments n\u00e9gatifs et positifs d'une liste d'entiers \u2693\ufe0e On consid\u00e8re une liste d'entiers [ 5, 0, 4, -5, 1, -3] et on souhaite calculer les sommes de ses \u00e9l\u00e9ments n\u00e9gatifs et positifs, le r\u00e9sultat sera donn\u00e9 sous forme de tuple (somme_neg,somme_pos) \u00c9crire une fonction somme2(liste) ci-dessous qui devra r\u00e9ussir les tests suivants : assert somme2 ([ 0 , 1 , 2 , 3 ]) == ( 0 , 6 ) assert somme2 ([ 5 , 0 , 4 , - 5 , 1 , - 3 ]) == ( - 8 , 10 ) assert somme2 ([]) == ( 0 , 0 ) assert somme2 ([ 0 , 1 , - 1 , 1 , 0 , 1 ]) == ( - 1 , 3 ) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Calcul de moyenne \u2693\ufe0e Il s'agit de calculer la moyenne des valeurs d'une liste. \u00c9crire une fonction moyenne1(liste) qui renvoie la moyenne des \u00e9l\u00e9ments de la liste, cette fonction devra r\u00e9ussir les tests suivants : assert moyenne1 ([ 10 , 12 , 9 , 8 , 15 ]) == ( 10 + 12 + 9 + 8 + 15 ) / 5 assert moyenne1 ([]) == 'liste vide' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Moyenne coefficient\u00e9e \u2693\ufe0e On dispose d'une liste de tuples (note, coefficient), on doit calculer la moyenne coefficient\u00e9e . \u00c9crire une fonction moyenne2(liste) qui renvoie la moyenne coefficient\u00e9e des \u00e9l\u00e9ments de la liste, cette fonction devra r\u00e9ussir les tests suivants : assert moyenne2 ([( 10 , 2 ),( 12 , 1 ),( 9 , 1 ),( 8 , 3 ),( 15 , 1 )]) == ( 10 * 2 + 12 + 9 + 8 * 3 + 15 ) / 8 assert moyenne2 ([]) == 'liste vide' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Avec des dictionnaires \u2693\ufe0e On consid\u00e8re le tableau suivant dont les \u00e9l\u00e9ments sont des dictionnaires : animaux = [ { 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }, { 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Tom' , 'espece' : 'chat' , 'age' : 7 , 'enclos' : 4 }, { 'nom' : 'Belle' , 'espece' : 'chien' , 'age' : 6 , 'enclos' : 3 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] \u00c9crire une fonction moyenne3(tableau) qui renvoie l'\u00e2ge moyen des chats, cette fonction devra r\u00e9ussir le test suivant : assert moyenne3 ( animaux ) == 5.0 Rappel : Parcourir un dictionnaire : for key in dico: instructions Acc\u00e9der aux valeurs : # Dans notre exemple animaux [ 1 ] # est un dictionnaire animaux [ 1 ][ \"nom\" ] # renvoie 'Titine Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Sommes en tout genre"},{"location":"sommes/#sommes-en-tout-genre","text":"La plupart des algorithmes de calcul de somme sont bas\u00e9s sur le principe suivant: On initialise une variable somme \u00e0 \\(0\\) On parcourt les \u00e9l\u00e9ments \u00e0 additionner en les ajoutant au fur et \u00e0 mesure \u00e0 somme Rappel : Parcours de listes Il y a deux fa\u00e7ons de parcourir des listes. Sur les \u00e9l\u00e9ments : for el in liste : instructions Sur les indices : for i in range ( len ( liste )): instructions","title":"Sommes en tout genre"},{"location":"sommes/#somme-des-elements-dune-liste-dentiers","text":"On consid\u00e8re une liste d'entiers [ 5, 0, 4, -5, 1, -3] et on souhaite calculer la somme de ses \u00e9l\u00e9ments. Sans utiliser la fonction sum de python, \u00e9crire une fonction somme1(liste) ci-dessous qui devra r\u00e9ussir les tests : assert somme1 ([ 0 , 1 , 2 , 3 ]) == 6 assert somme1 ([ 5 , 0 , 4 , - 5 , 1 , - 3 ]) == 2 assert somme1 ([]) == 0 assert somme1 ([ 1 ]) == 1 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Somme des \u00e9l\u00e9ments d'une liste d'entiers"},{"location":"sommes/#sommes-des-elements-negatifs-et-positifs-dune-liste-dentiers","text":"On consid\u00e8re une liste d'entiers [ 5, 0, 4, -5, 1, -3] et on souhaite calculer les sommes de ses \u00e9l\u00e9ments n\u00e9gatifs et positifs, le r\u00e9sultat sera donn\u00e9 sous forme de tuple (somme_neg,somme_pos) \u00c9crire une fonction somme2(liste) ci-dessous qui devra r\u00e9ussir les tests suivants : assert somme2 ([ 0 , 1 , 2 , 3 ]) == ( 0 , 6 ) assert somme2 ([ 5 , 0 , 4 , - 5 , 1 , - 3 ]) == ( - 8 , 10 ) assert somme2 ([]) == ( 0 , 0 ) assert somme2 ([ 0 , 1 , - 1 , 1 , 0 , 1 ]) == ( - 1 , 3 ) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Sommes des \u00e9l\u00e9ments n\u00e9gatifs et positifs d'une liste d'entiers"},{"location":"sommes/#calcul-de-moyenne","text":"Il s'agit de calculer la moyenne des valeurs d'une liste. \u00c9crire une fonction moyenne1(liste) qui renvoie la moyenne des \u00e9l\u00e9ments de la liste, cette fonction devra r\u00e9ussir les tests suivants : assert moyenne1 ([ 10 , 12 , 9 , 8 , 15 ]) == ( 10 + 12 + 9 + 8 + 15 ) / 5 assert moyenne1 ([]) == 'liste vide' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Calcul de moyenne"},{"location":"sommes/#moyenne-coefficientee","text":"On dispose d'une liste de tuples (note, coefficient), on doit calculer la moyenne coefficient\u00e9e . \u00c9crire une fonction moyenne2(liste) qui renvoie la moyenne coefficient\u00e9e des \u00e9l\u00e9ments de la liste, cette fonction devra r\u00e9ussir les tests suivants : assert moyenne2 ([( 10 , 2 ),( 12 , 1 ),( 9 , 1 ),( 8 , 3 ),( 15 , 1 )]) == ( 10 * 2 + 12 + 9 + 8 * 3 + 15 ) / 8 assert moyenne2 ([]) == 'liste vide' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Moyenne coefficient\u00e9e"},{"location":"sommes/#avec-des-dictionnaires","text":"On consid\u00e8re le tableau suivant dont les \u00e9l\u00e9ments sont des dictionnaires : animaux = [ { 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }, { 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Tom' , 'espece' : 'chat' , 'age' : 7 , 'enclos' : 4 }, { 'nom' : 'Belle' , 'espece' : 'chien' , 'age' : 6 , 'enclos' : 3 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] \u00c9crire une fonction moyenne3(tableau) qui renvoie l'\u00e2ge moyen des chats, cette fonction devra r\u00e9ussir le test suivant : assert moyenne3 ( animaux ) == 5.0 Rappel : Parcourir un dictionnaire : for key in dico: instructions Acc\u00e9der aux valeurs : # Dans notre exemple animaux [ 1 ] # est un dictionnaire animaux [ 1 ][ \"nom\" ] # renvoie 'Titine Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Avec des dictionnaires"},{"location":"tri/","text":"Les tris \u2693\ufe0e Voil\u00e0 une animation de 3 algorithmes de tris. Dans chaque cas prenez le temps de 'verbaliser' ce qui se passe... Rappel : voici un code qui permet de cr\u00e9er un tableau de 15 entiers al\u00e9atoirement choisis entre 0 et 100. from random import randint tab = [ randint ( 0 , 100 ) for i in range ( 15 )] Le tri par insertion \u2693\ufe0e Compl\u00e9ter le code suivant qui r\u00e9alise le tri par insertion et le tester. def tri_insertion ( t ): n = ... for i in range ( ... , n ): k = ... while k > 0 : if t [ ... ] > t [ k ]: t [ ... ], t [ k - 1 ] = t [ ... ], t [ k ] k = ... return t Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Le tri par s\u00e9lection \u2693\ufe0e Compl\u00e9ter le code suivant qui r\u00e9alise le tri par selection et le tester. def tri_selection ( t ): n = len ( t ) for i in range ( ... ): k = ... while k < n : if t [ i ] < t [ ... ]: t [ ... ], t [ i ] = t [ ... ], t [ k ] k = ... return t Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z Le tri \u00e0 bulles \u2693\ufe0e Compl\u00e9ter le code suivant qui r\u00e9alise le tri \u00e0 bulles et le tester. def tri_bulle ( t ): n = ... k = n - 1 while k > ... : for j in range ( ... ): if t [ ... ] > t [ ... ]: t [ ... ], t [ ... ] = t [ ... ], t [ ... ] k = ... return t Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Tri"},{"location":"tri/#les-tris","text":"Voil\u00e0 une animation de 3 algorithmes de tris. Dans chaque cas prenez le temps de 'verbaliser' ce qui se passe... Rappel : voici un code qui permet de cr\u00e9er un tableau de 15 entiers al\u00e9atoirement choisis entre 0 et 100. from random import randint tab = [ randint ( 0 , 100 ) for i in range ( 15 )]","title":"Les tris"},{"location":"tri/#le-tri-par-insertion","text":"Compl\u00e9ter le code suivant qui r\u00e9alise le tri par insertion et le tester. def tri_insertion ( t ): n = ... for i in range ( ... , n ): k = ... while k > 0 : if t [ ... ] > t [ k ]: t [ ... ], t [ k - 1 ] = t [ ... ], t [ k ] k = ... return t Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Le tri par insertion"},{"location":"tri/#le-tri-par-selection","text":"Compl\u00e9ter le code suivant qui r\u00e9alise le tri par selection et le tester. def tri_selection ( t ): n = len ( t ) for i in range ( ... ): k = ... while k < n : if t [ i ] < t [ ... ]: t [ ... ], t [ i ] = t [ ... ], t [ k ] k = ... return t Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Le tri par s\u00e9lection"},{"location":"tri/#le-tri-a-bulles","text":"Compl\u00e9ter le code suivant qui r\u00e9alise le tri \u00e0 bulles et le tester. def tri_bulle ( t ): n = ... k = n - 1 while k > ... : for j in range ( ... ): if t [ ... ] > t [ ... ]: t [ ... ], t [ ... ] = t [ ... ], t [ ... ] k = ... return t Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder A Z","title":"Le tri \u00e0 bulles"},{"location":"xtra/end_REM/","text":"Z","title":"end REM"},{"location":"xtra/start_REM/","text":"A","title":"start REM"}]}